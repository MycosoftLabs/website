/**
 * Penetration Testing API
 * 
 * Provides endpoints for network scanning, vulnerability assessment,
 * and security testing automation.
 * 
 * @version 1.0.0
 */

import { NextRequest, NextResponse } from 'next/server';
import {
  requestScan,
  getScanResult,
  getScanHistory,
  getDiscoveredHosts,
  getVulnerabilities,
  cancelScan,
  pingSweep,
  type ScanType,
  type ScanResult,
  type Vulnerability,
} from '@/lib/security/scanner';

// Configuration
const ALLOWED_TARGETS = (process.env.SCAN_TARGETS || '192.168.0.0/24,192.168.1.0/24').split(',');
const MAX_CONCURRENT_SCANS = parseInt(process.env.MAX_CONCURRENT_SCANS || '3');

// In-memory scan queue
const activeScanCount = { count: 0 };

/**
 * Validate target is allowed
 */
function isTargetAllowed(target: string): boolean {
  // Only allow scanning internal networks
  for (const allowed of ALLOWED_TARGETS) {
    const baseIP = allowed.split('/')[0];
    const octets = baseIP.split('.').slice(0, 2).join('.');
    if (target.startsWith(octets)) {
      return true;
    }
  }
  return false;
}

/**
 * GET /api/pentest
 */
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const action = searchParams.get('action') || 'status';

  try {
    switch (action) {
      case 'status':
        return getPentestStatus();

      case 'scan-result':
        const scanId = searchParams.get('id');
        if (!scanId) {
          return NextResponse.json({ error: 'Scan ID required' }, { status: 400 });
        }
        return getScanResultHandler(scanId);

      case 'scan-history':
        const limit = parseInt(searchParams.get('limit') || '50');
        return NextResponse.json({
          scans: await getScanHistory(limit),
        });

      case 'hosts':
        return NextResponse.json({
          hosts: await getDiscoveredHosts(),
        });

      case 'vulnerabilities':
        const vulnLimit = parseInt(searchParams.get('limit') || '100');
        const vulns = await getVulnerabilities();
        return NextResponse.json({
          vulnerabilities: vulns.slice(0, vulnLimit),
          total: vulns.length,
          bySeverity: {
            critical: vulns.filter(v => v.severity === 'critical').length,
            high: vulns.filter(v => v.severity === 'high').length,
            medium: vulns.filter(v => v.severity === 'medium').length,
            low: vulns.filter(v => v.severity === 'low').length,
          },
        });

      case 'topology':
        return getNetworkTopology();

      case 'allowed-targets':
        return NextResponse.json({
          targets: ALLOWED_TARGETS,
          max_concurrent: MAX_CONCURRENT_SCANS,
        });

      default:
        return NextResponse.json({ error: 'Unknown action' }, { status: 400 });
    }
  } catch (error) {
    console.error('Pentest API error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

/**
 * POST /api/pentest
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { action, ...data } = body;

    switch (action) {
      case 'scan-network':
        return startNetworkScan(data.target, data.type || 'ping');

      case 'scan-ports':
        return startPortScan(data.target, data.ports);

      case 'scan-vuln':
        return startVulnScan(data.target);

      case 'quick-sweep':
        return quickSweep(data.network);

      case 'cancel-scan':
        return cancelScanHandler(data.scan_id);

      case 'schedule-scan':
        return scheduleScan(data);

      default:
        return NextResponse.json(
          { error: 'Unknown action' },
          { status: 400 }
        );
    }
  } catch (error) {
    console.error('Pentest API POST error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// Handler functions

function getPentestStatus() {
  return NextResponse.json({
    status: 'ready',
    active_scans: activeScanCount.count,
    max_concurrent: MAX_CONCURRENT_SCANS,
    allowed_targets: ALLOWED_TARGETS,
    capabilities: [
      'ping_sweep',
      'port_scan',
      'service_detection',
      'vulnerability_scan',
      'os_detection',
    ],
    last_scan: null, // Would come from scan history
    uptime_seconds: Math.floor(process.uptime()),
  });
}

async function getScanResultHandler(scanId: string) {
  const result = await getScanResult(scanId);
  if (!result) {
    return NextResponse.json({ error: 'Scan not found' }, { status: 404 });
  }
  return NextResponse.json(result);
}

async function startNetworkScan(target: string, type: ScanType) {
  if (!target) {
    return NextResponse.json({ error: 'Target required' }, { status: 400 });
  }

  if (!isTargetAllowed(target)) {
    return NextResponse.json(
      { error: 'Target not in allowed scan range' },
      { status: 403 }
    );
  }

  if (activeScanCount.count >= MAX_CONCURRENT_SCANS) {
    return NextResponse.json(
      { error: 'Maximum concurrent scans reached' },
      { status: 429 }
    );
  }

  try {
    activeScanCount.count++;
    const scanId = await requestScan({ scanType: type, target });

    // Decrement count when scan completes (async)
    setTimeout(async () => {
      const result = await getScanResult(scanId);
      if (result?.status === 'completed' || result?.status === 'failed') {
        activeScanCount.count = Math.max(0, activeScanCount.count - 1);
      }
    }, 60000);

    return NextResponse.json({
      success: true,
      scan_id: scanId,
      type,
      target,
      message: `Scan started: ${type} on ${target}`,
    });
  } catch (error) {
    activeScanCount.count = Math.max(0, activeScanCount.count - 1);
    throw error;
  }
}

async function startPortScan(target: string, ports?: string) {
  if (!target) {
    return NextResponse.json({ error: 'Target required' }, { status: 400 });
  }

  if (!isTargetAllowed(target)) {
    return NextResponse.json(
      { error: 'Target not in allowed scan range' },
      { status: 403 }
    );
  }

  try {
    const scanId = await requestScan({
      scanType: 'syn',
      target,
      options: ports ? { ports } : undefined,
    });

    return NextResponse.json({
      success: true,
      scan_id: scanId,
      type: 'port_scan',
      target,
      ports: ports || 'top-1000',
    });
  } catch (error) {
    console.error('Port scan error:', error);
    return NextResponse.json({ error: 'Failed to start port scan' }, { status: 500 });
  }
}

async function startVulnScan(target: string) {
  if (!target) {
    return NextResponse.json({ error: 'Target required' }, { status: 400 });
  }

  if (!isTargetAllowed(target)) {
    return NextResponse.json(
      { error: 'Target not in allowed scan range' },
      { status: 403 }
    );
  }

  try {
    const scanId = await requestScan({
      scanType: 'vuln',
      target,
    });

    return NextResponse.json({
      success: true,
      scan_id: scanId,
      type: 'vulnerability_scan',
      target,
      message: 'Vulnerability scan started. This may take several minutes.',
    });
  } catch (error) {
    console.error('Vuln scan error:', error);
    return NextResponse.json({ error: 'Failed to start vulnerability scan' }, { status: 500 });
  }
}

async function quickSweep(network?: string) {
  const target = network || ALLOWED_TARGETS[0];
  
  if (!isTargetAllowed(target)) {
    return NextResponse.json(
      { error: 'Target not in allowed scan range' },
      { status: 403 }
    );
  }

  try {
    const hosts = await pingSweep(target);
    return NextResponse.json({
      success: true,
      network: target,
      hosts_found: hosts.length,
      hosts,
    });
  } catch (error) {
    console.error('Quick sweep error:', error);
    return NextResponse.json({ error: 'Ping sweep failed' }, { status: 500 });
  }
}

async function cancelScanHandler(scanId: string) {
  if (!scanId) {
    return NextResponse.json({ error: 'Scan ID required' }, { status: 400 });
  }

  const cancelled = await cancelScan(scanId);
  if (cancelled) {
    activeScanCount.count = Math.max(0, activeScanCount.count - 1);
    return NextResponse.json({
      success: true,
      message: `Scan ${scanId} cancelled`,
    });
  }

  return NextResponse.json(
    { error: 'Scan not found or already completed' },
    { status: 404 }
  );
}

async function scheduleScan(data: {
  target: string;
  type: ScanType;
  schedule: string; // cron expression
  name: string;
}) {
  // In production, this would create a scheduled task
  // For now, just validate and return confirmation
  if (!isTargetAllowed(data.target)) {
    return NextResponse.json(
      { error: 'Target not in allowed scan range' },
      { status: 403 }
    );
  }

  return NextResponse.json({
    success: true,
    message: 'Scheduled scan created',
    schedule: {
      id: `sched-${Date.now()}`,
      name: data.name,
      target: data.target,
      type: data.type,
      cron: data.schedule,
      next_run: new Date(Date.now() + 3600000).toISOString(), // Placeholder
    },
  });
}

async function getNetworkTopology() {
  // Get discovered hosts and build topology
  const hosts = await getDiscoveredHosts();
  
  // Group by network segment
  const segments: Record<string, typeof hosts> = {};
  for (const host of hosts) {
    const octets = host.ip.split('.');
    const segment = `${octets[0]}.${octets[1]}.${octets[2]}.0/24`;
    if (!segments[segment]) {
      segments[segment] = [];
    }
    segments[segment].push(host);
  }

  // Build topology structure
  const topology = {
    gateway: {
      ip: '192.168.0.1',
      name: 'UniFi Dream Machine Pro',
      type: 'router',
      connections: Object.keys(segments).length,
    },
    segments: Object.entries(segments).map(([network, segmentHosts]) => ({
      network,
      host_count: segmentHosts.length,
      hosts: segmentHosts.map(h => ({
        ip: h.ip,
        hostname: h.hostname,
        mac: h.mac,
        vendor: h.vendor,
        os: h.os,
        open_ports: h.ports.length,
        services: h.ports.map(p => p.service).filter(Boolean),
      })),
    })),
    total_hosts: hosts.length,
    scan_time: new Date().toISOString(),
  };

  return NextResponse.json(topology);
}
